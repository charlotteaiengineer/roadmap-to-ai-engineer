---
title: "Week of Oct 13, 2025"
description: "Week 1 — Practical Python: sets, tuples, dictionaries, mutability & hashing."
date: 2025-10-13
categories: [Week, 2025]
jupyter: python3
---

## Learning outcomes

-   Understand how and when to use sets, tuples, and dictionaries
-   Explain mutability vs. immutability and implications for hashing
-   Apply tuple unpacking safely and predictably

## Key notes

-   Empty set literal is `set()`, not `{}` (that’s an empty dict).
-   Sets are unordered, unique collections; you cannot index into a set.
-   Tuples are immutable; beware stray trailing commas creating tuples unexpectedly.
-   Tuple unpacking requires counts to match; use `_` for values you do not need.
-   Dictionaries are keyed mappings; use `in` to check key existence.
-   Hashable typically implies immutable; lists/dicts/sets are unhashable, tuples/ints/str are hashable.

## Resources

-   Frontend Masters — Practical Guide to Python (full course): <https://frontendmasters.com/courses/practical-python/>

## Exercises

-   Practice in REPL: construct sets from lists, perform tuple unpacking, and update dicts.

## Readiness checklist

-   [ ] Can create and manipulate sets, and explain why they are unordered
-   [ ] Can define tuples and avoid accidental tuple creation via trailing commas
-   [ ] Can unpack tuples defensively and handle mismatched lengths
-   [ ] Can use dictionaries idiomatically (membership checks, updates)

## Examples

### Numbers and booleans

```{python}
a = 12
b = 3.5
total = a + b
is_equal = (a == 2)
truthy = True and (1 < 2)
falsy = False or (2 > 5)
not_val = not False

print(a, type(a))
print(b, type(b))
print(total)
print(is_equal, truthy, falsy, not_val)
```

### Strings and f-strings

```{python}
name = "Charlotte"
lang = "Python"
msg = f"Hi {name}, welcome to {lang}!"

print(name.upper())
print(len(name))
print("thon" in lang)
print(msg)
```

### Lists

```{python}
nums = [1, 2, 3]
nums.append(4)
sliced = nums[1:3]
doubled = [x * 2 for x in nums]

print(nums)
print(sliced)
print(doubled)
```

### Tuples

```{python}
t = (1, "a", True)
single = (42,)
packed = 1, 2  # tuple without parentheses
x, y = (10, 20)  # unpacking

print(t)
print(single)
print(packed)
print(x, y)

# t[0] = 99  # TypeError: 'tuple' object does not support item assignment
```

### Dictionaries

```{python}
user = {"name": "Charlotte", "role": "AI Engineer"}
user["city"] = "Ipswich"

print(user["name"])       # indexing by key
print("role" in user)      # membership check on keys
print(user)
```

### Sets

```{python}
names = ["alice", "bob", "alice"]
s = set(names)
s.add("carol")

print(s)
print("alice" in s)
```

### Hash function and hashability

```{python}
print(hash(("a", 1)))  # tuples are hashable if their items are hashable
print(hash("abc"))

# hash([1, 2])   # TypeError: unhashable type: 'list'
# hash({"k": 1}) # TypeError: unhashable type: 'dict'
```

### Logic: and / or / in

```{python}
print(True and False)
print(True or False)
print(False or 0)
print(0 or "fallback")
print("x" and "y")      # returns last truthy operand
print("py" in "python")  # substring membership
```

### Functions

```{python}

def my_function(x=4):
   return x + 2

my_function()
```

```{python}

def my_other_function(x):
   return x * 2

my_other_function(21312)
```

```{python}

def another_cat(x, y, z=12):
   return z + (x + y)

another_cat(1, 2)
```

### Conditionals

```{python}

def my_dogs(x, one, two):
    if x == 2:
        return f"my doggos are {one} and {two}"
    elif x > 2:
        return "Soon! soon we will have them all!"
    else: 
        return "Got no doggos"

my_dogs(1, "Annie", "Anubis")

```

```{python}

def fizzbuzz(number):
    if (number % 3 == 0) and (number % 5 == 0):
        print("fizz")
    else: print("buzz")

fizzbuzz(15)
fizzbuzz(5)
```

### Loops

```{python}

family = ["Annie", "Anubis", "Alex", "Charlotte"]

for family_member in family:
    print(f"My name is {family_member}!")

print(f"outside of the loop {family_member}")

list(enumerate(family))
```

enumerate returns list of tuples , first item index, second item the value

```{python}

colours = ["Red", "Yellow", "Pink", "Green", "Orange", "Purple", "Blue"]

for index, colour in enumerate(colours):
    print(f"this is the greatest colour {colour} number {index}")

```

```{python}

concepts_to_learn = {
    "Python": "Language",
    "TensorFlow": "Execution Env",
    "Pytorch": "differnt exectuion place",
    "Deep Learning": "Neural networks and that"
}

for foo in concepts_to_learn:
    print(foo)

```

```{python}

concepts_to_learn.items()
```

```{python}

for key, value in concepts_to_learn.items():
    print(key) 
    print("----")
    print(value)

```

```{python}

x = 0
while x < 5:
    print(x)
    x += 1
```

```{python}

names = ["Lisa", "Bob", "Jeremy", "Django", "Mario"]

def return_target(target="Jeremy"):
    for name in names:
        print(name)
        if name == target:
            print(f"we found {target}!")
            return name
```

### List comprehensions

```{python}

names = ["Lisa", "Bob", "Jeremy", "Django", "Mario"]
my_list = []

for name in names:
    my_list.append(len(name))

print("First way: ", my_list)

print("Shorter way:", [len(name) for name in names])
```

```{python}

nums = [0, 1, 2, 3, 4]

[num * 2 for num in nums] 
```

### Slicing

```{python}

my_cake = "Hey this is a big cake!"
my_cake[14:22]

my_cake[:18]
my_cake[19:]
my_cake[-1]
```

### files

-   `open("my_file.txt")`

-   `open("my_file.txt", "w")`

-   `open("my_file.txt", "a")`