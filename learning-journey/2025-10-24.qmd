---
title: "Intermediate Python"
description: "frontendmaster course"
date: 2025-10-24
jupyter: python3
categories: [python]
image: https://static.frontendmasters.com/assets/courses/2019-05-01-intermediate-python/posterframe.webp
---

# [Intermediate Python - Frontend Masters - Nina Zakharenko](https://frontendmasters.com/courses/intermediate-python/)

```{python}
my_data = "hello, I am Charlotte, I am learning Python..."
my_data.split(",") # creates a list split by ,
```

```{python}
",".join(my_data) # creates a string joined by ,
```

```{python}
"ðŸ’»".join(my_data) # creates a string joined by ðŸ’»
```

```{python}
my_data.split(" ")
" ".join(my_data) # careful, this will add a space between each character
```


```{python}
"".join(my_data) # join on empty string
```

```{python}
gym_set = "Deadlifts,Hip Thrusts,Squats"
gym_set.split(",") # creates a list split by ,
first_excercise, second_excercise, third_excercise = gym_set.split(",")
first_excercise
```

### Type Conversion

```{python}
int("123")
```


```{python}
float("123")
```

```{python}
str(123)
```

```{python}
name = ["Charlotte", "Alex", "Anubis", "Annie", "Anubis", "Charlotte", "Alex", "Annie", "Anubis"]
set(name) # creates a set of unique names. Sets CANNOT have duplicate values.
```


```{python}
sorted(set(name)) # creates a list of unique names sorted alphabetically, lists have ORDER. sets do not.
```

### List Comprehensions

```{python}
for n in name: print(n.upper())
```


```{python}
lowercase_names = []
for n in name: 
    lowercase_names.append(n.lower())
print(lowercase_names)
```

```{python}
[n.upper() for n in name] # list comprehension
# action you want to perform on each item in the list is first arg  
```

```{python}
list(range(10)) # peak inside what range is doing
```

```{python}
list(range(1,4))
```

```{python}
for num in range(6): print(num)
```

```{python}
6 % 2 # modulo operator
```

```{python}
fizz_buzz = []
for num in range(55, 74):
    if num % 3 == 0 and num % 5 == 0:
        fizz_buzz.append(f"{num} FizzBuzz")
    elif num % 3 == 0:
        fizz_buzz.append(f"{num} Fizz")
    elif num % 5 == 0:
        fizz_buzz.append(f"{num} Buzz")
    else:
        fizz_buzz.append(num)
print(fizz_buzz)
```

### List Operations

```{python}
squares = [num * num for num in range(10)]
squares
```

```{python}
sum(squares)
```

```{python}
max(squares)
```

```{python}
min(squares)
```

```{python}
len(squares)
```

```{python}
sorted(squares, reverse=True)
```


```{python}
# get largest number in list
lottery_numbers = "12, 23, 34, 45, 56, 2" 
```

```{python}
lottery_numbers.split(", ")
```

```{python}
[int(num) for num in lottery_numbers.split(", ")]
```

```{python}
max([int(num) for num in lottery_numbers.split(", ")])
```

```{python}
[num * num for num in range(10)] # ordered list
```

### Set Operations

```{python}
{num * num for num in range(10)} # unordered set
```

### Dictionaries

```{python}
{f"square of {num}": num * num for num in range(10)} # unordered set
```

### Generator Expression

Generators are cruical in AI/ML, its a lazy evalution. They produce a sequence lazily, **yielding one item at a time** instead of building the whole list in memory.

- Memory efficient (stream large data)
- Fast start-up (compute-on-demand)
- Composable (pipe transformations)

There's an issue that you're constantly pushing values to a potentially infinite queue. This takes up a load of memory. 

Generators don't return; they yield. 

There's no index positions. 

Define what's going to happen, only run on yield. Yielding is like running once and returning a value.

in `range(0,5)` each number is **generated** one by one as its looped through.

```{python}
family = ["Annie", "Anubis", "Alex", "Charlotte"]
(len(name) for name in family)
```

you can pass a generator comprehension into a function that expects an iterable.

```{python}
set((len(name) for name in family))
```

```{python}
sum((len(name) for name in family))
```

To get items out of a generator you need to iterate over it.

```{python}
my_generator = (num * num for num in range(10))

for num in my_generator:
    print(num)
```

### zip function

```{python}
squares = {f"square of {num}": num * num for num in range(10)}
squares.keys() # get the keys 
```

```{python}
squares.values() # get the values 
```

```{python}
squares.items() # get the key values 
```